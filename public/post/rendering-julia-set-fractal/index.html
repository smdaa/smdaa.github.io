<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Rendering Julia set fractals | smdaa</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/post/">Posts</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Rendering Julia set fractals</span></h1>

<h2 class="date">2024/11/07</h2>
</div>

<main>
<p><a href="https://en.wikipedia.org/wiki/Julia_set">The Julia set</a>, named after the french mathematician Gaston Julia, represents a complex pattern generated by iterating the function $f(z) = z^2 + c$ on complex numbers. Each point in the complex plane is tested by repeatedly applying this function, with its behavior revealing whether it &ldquo;escapes&rdquo; to infinity or stays bounded. The resulting set of points that remain bounded forms intricate, self-similar shapes that vary depending on the value of $c$.</p>
<p>In this article, we’ll explore how to efficiently render the Julia set fractals on the CPU and implement a smooth, asynchronous zooming effect.</p>
<p><a href="https://github.com/smdaa/creative-coding/blob/main/src/example_3/main.cpp">View source code on GitHub</a></p>
<p><img src="/assets/rendering-julia-set-fractal/render.png" alt=""></p>
<div class="toc">
  <h2>Table of Contents</h2>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#why-we-will-avoid-the-gpu">Why we will avoid the GPU</a></li>
    <li><a href="#cpu-julia-iterations">CPU Julia iterations</a>
      <ul>
        <li><a href="#naive-implementation">Naive implementation</a></li>
        <li><a href="#rearranging-calculations">Rearranging calculations</a></li>
        <li><a href="#using-avx2-intrinsics">Using AVX2 intrinsics</a></li>
      </ul>
    </li>
    <li><a href="#rendering-to-the-screen">Rendering to the screen</a>
      <ul>
        <li><a href="#mapping-screen-coordinates-to-the-complex-plane">Mapping screen coordinates to the complex plane</a></li>
        <li><a href="#color-mapping-with-a-lut">Color mapping with a LUT</a></li>
        <li><a href="#enhancing-image-quality-with-supersampling">Enhancing image quality with supersampling</a></li>
        <li><a href="#putting-it-all-together">Putting it all together</a></li>
        <li><a href="#user-interactivity">User interactivity</a></li>
        <li><a href="#results">Results</a></li>
      </ul>
    </li>
    <li><a href="#smooth-zooming-with-asynchronous-rendering">Smooth zooming with asynchronous rendering</a>
      <ul>
        <li><a href="#renderer-class">Renderer class</a></li>
        <li><a href="#results-1">Results</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>
<h2 id="why-we-will-avoid-the-gpu">Why we will avoid the GPU</h2>
<p><a href="https://fr.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL shaders</a> are programs that run directly on the graphics card, making them an ideal choice for rendering fractals due to their parallel processing power. However, they come with a significant limitation: GLSL shaders support only single-precision floating-point arithmetic. When zooming deeply, the reduced precision can lead to visible artifacts and loss of detail at relatively shallow zoom levels.</p>
<p>Here is an example you can try in <a href="https://www.shadertoy.com/new">Shadertoy</a>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">mainImage</span>( out vec4 fragColor, in vec2 fragCoord )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vec2 resolution <span style="color:#000;font-weight:bold">=</span> iResolution.xy;
</span></span><span style="display:flex;"><span>    vec2 center <span style="color:#000;font-weight:bold">=</span> vec2(<span style="color:#099">0.0</span>, <span style="color:#099">0.0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">float</span> scale <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">100000.0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> maxIterations <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1000</span>;
</span></span><span style="display:flex;"><span>    vec2 scaledCoord <span style="color:#000;font-weight:bold">=</span> (fragCoord <span style="color:#000;font-weight:bold">-</span> resolution <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">0.5</span>) <span style="color:#000;font-weight:bold">/</span> scale <span style="color:#000;font-weight:bold">+</span> center;
</span></span><span style="display:flex;"><span>    vec2 c <span style="color:#000;font-weight:bold">=</span> vec2(<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.7269</span>, <span style="color:#099">0.1889</span>);
</span></span><span style="display:flex;"><span>    vec2 z <span style="color:#000;font-weight:bold">=</span> scaledCoord;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> iterations;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (iterations <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; iterations <span style="color:#000;font-weight:bold">&lt;</span> maxIterations; iterations<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> (dot(z, z) <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#099">4.0</span>) <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        z <span style="color:#000;font-weight:bold">=</span> vec2(z.x <span style="color:#000;font-weight:bold">*</span> z.x <span style="color:#000;font-weight:bold">-</span> z.y <span style="color:#000;font-weight:bold">*</span> z.y, <span style="color:#099">2.0</span> <span style="color:#000;font-weight:bold">*</span> z.x <span style="color:#000;font-weight:bold">*</span> z.y) <span style="color:#000;font-weight:bold">+</span> c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">float</span> color <span style="color:#000;font-weight:bold">=</span> <span style="color:#458;font-weight:bold">float</span>(iterations) <span style="color:#000;font-weight:bold">/</span> <span style="color:#458;font-weight:bold">float</span>(maxIterations);
</span></span><span style="display:flex;"><span>    fragColor <span style="color:#000;font-weight:bold">=</span> vec4(vec3(color), <span style="color:#099">1.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We see that we lose details at a scale of 1e5:</p>
<p><img src="/assets/rendering-julia-set-fractal/julia-gpu.png" alt=""></p>
<h2 id="cpu-julia-iterations">CPU Julia iterations</h2>
<p>In this section, we will focus solely on the function that takes in coordinates on the complex plane and produces the number of iterations for the Julia set calculation.</p>
<h3 id="naive-implementation">Naive implementation</h3>
<p>We will begin with a straightforward implementation of the Julia set formula $f(z) = z^2 + c$. In this basic version, we directly compute the complex number multiplication and addition operations as needed.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">computeJulia</span>(<span style="color:#458;font-weight:bold">double</span> px, <span style="color:#458;font-weight:bold">double</span> py, <span style="color:#458;font-weight:bold">double</span> cx, <span style="color:#458;font-weight:bold">double</span> cy,
</span></span><span style="display:flex;"><span>                    <span style="color:#458;font-weight:bold">double</span> escapeRadiusSquared, <span style="color:#458;font-weight:bold">int</span> maxIterations) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> x <span style="color:#000;font-weight:bold">=</span> px;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> y <span style="color:#000;font-weight:bold">=</span> py;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> iterations <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> (iterations <span style="color:#000;font-weight:bold">&lt;</span> maxIterations) {
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">double</span> magnitudeSquared <span style="color:#000;font-weight:bold">=</span> x<span style="color:#000;font-weight:bold">*</span>x <span style="color:#000;font-weight:bold">+</span> y<span style="color:#000;font-weight:bold">*</span>y;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> (magnitudeSquared <span style="color:#000;font-weight:bold">&gt;</span> escapeRadiusSquared) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">double</span> newX <span style="color:#000;font-weight:bold">=</span> x<span style="color:#000;font-weight:bold">*</span>x <span style="color:#000;font-weight:bold">-</span> y<span style="color:#000;font-weight:bold">*</span>y <span style="color:#000;font-weight:bold">+</span> cx;
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">double</span> newY <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span><span style="color:#000;font-weight:bold">*</span>x<span style="color:#000;font-weight:bold">*</span>y <span style="color:#000;font-weight:bold">+</span> cy;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        x <span style="color:#000;font-weight:bold">=</span> newX;
</span></span><span style="display:flex;"><span>        y <span style="color:#000;font-weight:bold">=</span> newY;
</span></span><span style="display:flex;"><span>        iterations<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> iterations;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="rearranging-calculations">Rearranging calculations</h3>
<p>To optimize the computation, we can reduce the number of multiplications by pre-calculating common terms. The second version stores the squares $x^2$ and $y^2$ at the start of each iteration. These values are then reused in both the escape condition check and the next position calculation. While mathematically equivalent to the first version, this arrangement can provide noticeable performance improvements.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">computeJulia</span>(<span style="color:#458;font-weight:bold">double</span> px, <span style="color:#458;font-weight:bold">double</span> py, <span style="color:#458;font-weight:bold">double</span> cx, <span style="color:#458;font-weight:bold">double</span> cy,
</span></span><span style="display:flex;"><span>                    <span style="color:#458;font-weight:bold">double</span> escapeRadiusSquared, <span style="color:#458;font-weight:bold">int</span> maxIterations) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> x <span style="color:#000;font-weight:bold">=</span> px;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> y <span style="color:#000;font-weight:bold">=</span> py;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> iterations <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> (iterations <span style="color:#000;font-weight:bold">&lt;</span> maxIterations) {
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">double</span> x2 <span style="color:#000;font-weight:bold">=</span> x<span style="color:#000;font-weight:bold">*</span>x;
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">double</span> y2 <span style="color:#000;font-weight:bold">=</span> y<span style="color:#000;font-weight:bold">*</span>y;
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">double</span> xy <span style="color:#000;font-weight:bold">=</span> x<span style="color:#000;font-weight:bold">*</span>y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">double</span> magnitudeSquared <span style="color:#000;font-weight:bold">=</span> x2 <span style="color:#000;font-weight:bold">+</span> y2;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> (magnitudeSquared <span style="color:#000;font-weight:bold">&gt;</span> escapeRadiusSquared) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        x <span style="color:#000;font-weight:bold">=</span> x2 <span style="color:#000;font-weight:bold">-</span> y2 <span style="color:#000;font-weight:bold">+</span> cx;
</span></span><span style="display:flex;"><span>        y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span><span style="color:#000;font-weight:bold">*</span>xy <span style="color:#000;font-weight:bold">+</span> cy;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        iterations<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> iterations;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="using-avx2-intrinsics">Using AVX2 intrinsics</h3>
<p>To achieve further performance gains, we leverage AVX2 SIMD instructions. This vectorized implementation processes four points simultaneously using 256-bit wide vectors <code>__m256d</code>. The escape condition is checked using a vector comparison <code>_mm256_cmp_pd</code>, creating a mask that&rsquo;s used to selectively increment iteration counts only for points that haven&rsquo;t escaped.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>__m256i <span style="color:#900;font-weight:bold">computeJulia</span>(__m256d positionX, __m256d positionY, __m256d constantX,
</span></span><span style="display:flex;"><span>                     __m256d constantY, __m256d escapeRadiusSquared,
</span></span><span style="display:flex;"><span>                     <span style="color:#458;font-weight:bold">int</span> maxIterations) {
</span></span><span style="display:flex;"><span>  __m256d x <span style="color:#000;font-weight:bold">=</span> positionX;
</span></span><span style="display:flex;"><span>  __m256d y <span style="color:#000;font-weight:bold">=</span> positionY;
</span></span><span style="display:flex;"><span>  __m256i iterations <span style="color:#000;font-weight:bold">=</span> _mm256_setzero_si256();
</span></span><span style="display:flex;"><span>  __m256i ones <span style="color:#000;font-weight:bold">=</span> _mm256_set1_epi64x(<span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> maxIterations; <span style="color:#000;font-weight:bold">++</span>i) {
</span></span><span style="display:flex;"><span>    __m256d x2 <span style="color:#000;font-weight:bold">=</span> _mm256_mul_pd(x, x);
</span></span><span style="display:flex;"><span>    __m256d y2 <span style="color:#000;font-weight:bold">=</span> _mm256_mul_pd(y, y);
</span></span><span style="display:flex;"><span>    __m256d mag2 <span style="color:#000;font-weight:bold">=</span> _mm256_add_pd(x2, y2);
</span></span><span style="display:flex;"><span>    __m256d mask <span style="color:#000;font-weight:bold">=</span> _mm256_cmp_pd(mag2, escapeRadiusSquared, _CMP_LT_OQ);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (_mm256_movemask_pd(mask) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>    __m256d xy <span style="color:#000;font-weight:bold">=</span> _mm256_mul_pd(x, y);
</span></span><span style="display:flex;"><span>    __m256d newX <span style="color:#000;font-weight:bold">=</span> _mm256_add_pd(_mm256_sub_pd(x2, y2), constantX);
</span></span><span style="display:flex;"><span>    y <span style="color:#000;font-weight:bold">=</span> _mm256_add_pd(_mm256_add_pd(xy, xy), constantY);
</span></span><span style="display:flex;"><span>    x <span style="color:#000;font-weight:bold">=</span> newX;
</span></span><span style="display:flex;"><span>    iterations <span style="color:#000;font-weight:bold">=</span> _mm256_add_epi64(
</span></span><span style="display:flex;"><span>        iterations, _mm256_and_si256(ones, _mm256_castpd_si256(mask)));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> iterations;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="rendering-to-the-screen">Rendering to the screen</h2>
<h3 id="mapping-screen-coordinates-to-the-complex-plane">Mapping screen coordinates to the complex plane</h3>
<p>To visualize the Julia set, we map screen coordinates $(x, y)$ to complex plane coordinates $(a, b)$ using three main steps: centering, scaling, and offsetting.</p>
<p>Centering shifts the screen origin from the top-left corner to the center, allowing symmetry around the middle.</p>
<p>Scaling, controlled by a factor $s$, lets us zoom in and out on the fractal, while maintaining the aspect ratio by normalizing $x$ and $y$ relative to the screen’s width.</p>
<p>Offsetting by $(x_0, y_0)$ repositions the center of the screen to a specific point on the complex plane, enabling exploration of different regions of the fractal.</p>
<p>$$
a = \frac{x - \frac{W}{2}}{s \cdot \frac{W}{2}} + x_0
$$</p>
<p>$$
b = \frac{y - \frac{H}{2}}{s \cdot \frac{W}{2}} + y_0
$$</p>
<h3 id="color-mapping-with-a-lut">Color mapping with a LUT</h3>
<p>Coloring is done using a Look-Up Table (LUT), which provides a fast way to map iteration counts to colors. The <code>generatePalette</code> function interpolates between base colors, creating a smooth gradient based on max iterations. Using a LUT eliminates the need to recompute colors repeatedly.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#000;font-weight:bold">::</span>vector<span style="color:#000;font-weight:bold">&lt;</span>ci<span style="color:#000;font-weight:bold">::</span>Color<span style="color:#000;font-weight:bold">&gt;</span> generatePalette(<span style="color:#000;font-weight:bold">const</span> std<span style="color:#000;font-weight:bold">::</span>vector<span style="color:#000;font-weight:bold">&lt;</span>ci<span style="color:#000;font-weight:bold">::</span>Color<span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#000;font-weight:bold">&amp;</span>baseColors,
</span></span><span style="display:flex;"><span>                                       <span style="color:#458;font-weight:bold">int</span> maxIterations) {
</span></span><span style="display:flex;"><span>  std<span style="color:#000;font-weight:bold">::</span>vector<span style="color:#000;font-weight:bold">&lt;</span>ci<span style="color:#000;font-weight:bold">::</span>Color<span style="color:#000;font-weight:bold">&gt;</span> palette(maxIterations <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>  palette[maxIterations] <span style="color:#000;font-weight:bold">=</span> ci<span style="color:#000;font-weight:bold">::</span>Color(<span style="color:#099">0.1f</span>, <span style="color:#099">0.1f</span>, <span style="color:#099">0.3f</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> maxIterations; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">float</span> t <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">float</span>)i <span style="color:#000;font-weight:bold">/</span> maxIterations;
</span></span><span style="display:flex;"><span>    t <span style="color:#000;font-weight:bold">=</span> t <span style="color:#000;font-weight:bold">*</span> (baseColors.size() <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> idx <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">static_cast</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">&gt;</span>(t);
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">float</span> fract <span style="color:#000;font-weight:bold">=</span> t <span style="color:#000;font-weight:bold">-</span> idx;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">const</span> ci<span style="color:#000;font-weight:bold">::</span>Color <span style="color:#000;font-weight:bold">&amp;</span>c1 <span style="color:#000;font-weight:bold">=</span> baseColors[idx];
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">const</span> ci<span style="color:#000;font-weight:bold">::</span>Color <span style="color:#000;font-weight:bold">&amp;</span>c2 <span style="color:#000;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>        baseColors[std<span style="color:#000;font-weight:bold">::</span>min(idx <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>, (<span style="color:#458;font-weight:bold">int</span>)baseColors.size() <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>)];
</span></span><span style="display:flex;"><span>    palette[i] <span style="color:#000;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>        ci<span style="color:#000;font-weight:bold">::</span>Color(ci<span style="color:#000;font-weight:bold">::</span>lerp(c1.r, c2.r, fract), ci<span style="color:#000;font-weight:bold">::</span>lerp(c1.g, c2.g, fract),
</span></span><span style="display:flex;"><span>                  ci<span style="color:#000;font-weight:bold">::</span>lerp(c1.b, c2.b, fract));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> palette;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="enhancing-image-quality-with-supersampling">Enhancing image quality with supersampling</h3>
<p>To improve image quality and reduce aliasing artifacts, supersampling is applied. In this approach, each pixel is divided into multiple sub-pixel samples, with coordinates slightly offset from the main pixel center. For each sub-sample, the Julia set function is evaluated, and the results are averaged to produce a smoother, higher-quality final color for the pixel.</p>
<table>
  <thead>
      <tr>
          <th>Supersampling Count: 1</th>
          <th>Supersampling Count: 4</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><img src="/assets/rendering-julia-set-fractal/supersampling-1.png" alt=""></td>
          <td><img src="/assets/rendering-julia-set-fractal/supersampling-4.png" alt=""></td>
      </tr>
  </tbody>
</table>
<h3 id="putting-it-all-together">Putting it all together</h3>
<p>Combining everything, the <code>renderJulia</code> function integrates coordinate transformations, supersampling, and color mapping to render the fractal with OpenMP parallelism onto the <code>ci::Surface32f</code> object:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">renderJulia</span>(ci<span style="color:#000;font-weight:bold">::</span>Surface32f <span style="color:#000;font-weight:bold">&amp;</span>surface, <span style="color:#000;font-weight:bold">const</span> RenderParameters <span style="color:#000;font-weight:bold">&amp;</span>params,
</span></span><span style="display:flex;"><span>                 <span style="color:#000;font-weight:bold">const</span> std<span style="color:#000;font-weight:bold">::</span>vector<span style="color:#000;font-weight:bold">&lt;</span>ci<span style="color:#000;font-weight:bold">::</span>Color<span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#000;font-weight:bold">&amp;</span>palette) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> surfaceWidth <span style="color:#000;font-weight:bold">=</span> surface.getWidth();
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> screenHeight <span style="color:#000;font-weight:bold">=</span> surface.getHeight();
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">double</span> surfaceWidthHalf <span style="color:#000;font-weight:bold">=</span> surfaceWidth <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">2.0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">double</span> surfaceHeightHalf <span style="color:#000;font-weight:bold">=</span> screenHeight <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">2.0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">double</span> scaleInv <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1.0</span> <span style="color:#000;font-weight:bold">/</span> params.scale;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">double</span> totalSamples <span style="color:#000;font-weight:bold">=</span> params.samplingCount <span style="color:#000;font-weight:bold">*</span> params.samplingCount;
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#pragma omp parallel for
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; y <span style="color:#000;font-weight:bold">&lt;</span> screenHeight; y <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; x <span style="color:#000;font-weight:bold">&lt;</span> surfaceWidth; x <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">4</span>) {
</span></span><span style="display:flex;"><span>      __m256d surfaceWidthHalfVec <span style="color:#000;font-weight:bold">=</span> _mm256_set1_pd(surfaceWidthHalf);
</span></span><span style="display:flex;"><span>      __m256d scaleInvVec <span style="color:#000;font-weight:bold">=</span> _mm256_set1_pd(scaleInv);
</span></span><span style="display:flex;"><span>      __m256d xVec <span style="color:#000;font-weight:bold">=</span> _mm256_set_pd(x <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">3</span>, x <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">2</span>, x <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>, x);
</span></span><span style="display:flex;"><span>      __m256d xShifted <span style="color:#000;font-weight:bold">=</span> _mm256_sub_pd(xVec, surfaceWidthHalfVec);
</span></span><span style="display:flex;"><span>      <span style="color:#458;font-weight:bold">double</span> accumulatedR[<span style="color:#099">4</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">0</span>}, accumulatedG[<span style="color:#099">4</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>      <span style="color:#458;font-weight:bold">double</span> accumulatedB[<span style="color:#099">4</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">0</span>}, accumulatedA[<span style="color:#099">4</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> sy <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; sy <span style="color:#000;font-weight:bold">&lt;</span> params.samplingCount; sy<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> sx <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; sx <span style="color:#000;font-weight:bold">&lt;</span> params.samplingCount; sx<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#458;font-weight:bold">double</span> subX <span style="color:#000;font-weight:bold">=</span> sx <span style="color:#000;font-weight:bold">/</span> <span style="color:#000;font-weight:bold">static_cast</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span><span style="color:#000;font-weight:bold">&gt;</span>(params.samplingCount);
</span></span><span style="display:flex;"><span>          <span style="color:#458;font-weight:bold">double</span> subY <span style="color:#000;font-weight:bold">=</span> sy <span style="color:#000;font-weight:bold">/</span> <span style="color:#000;font-weight:bold">static_cast</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span><span style="color:#000;font-weight:bold">&gt;</span>(params.samplingCount);
</span></span><span style="display:flex;"><span>          __m256d posX <span style="color:#000;font-weight:bold">=</span> _mm256_add_pd(
</span></span><span style="display:flex;"><span>              _mm256_mul_pd(
</span></span><span style="display:flex;"><span>                  _mm256_mul_pd(_mm256_add_pd(xShifted, _mm256_set1_pd(subX)),
</span></span><span style="display:flex;"><span>                                scaleInvVec),
</span></span><span style="display:flex;"><span>                  _mm256_set1_pd(<span style="color:#099">1.0</span> <span style="color:#000;font-weight:bold">/</span> surfaceWidthHalf)),
</span></span><span style="display:flex;"><span>              _mm256_set1_pd(params.offsetX));
</span></span><span style="display:flex;"><span>          __m256d posY <span style="color:#000;font-weight:bold">=</span> _mm256_set1_pd((y <span style="color:#000;font-weight:bold">+</span> subY <span style="color:#000;font-weight:bold">-</span> surfaceHeightHalf) <span style="color:#000;font-weight:bold">/</span>
</span></span><span style="display:flex;"><span>                                            surfaceWidthHalf <span style="color:#000;font-weight:bold">*</span> scaleInv <span style="color:#000;font-weight:bold">+</span>
</span></span><span style="display:flex;"><span>                                        params.offsetY);
</span></span><span style="display:flex;"><span>          __m256d constX <span style="color:#000;font-weight:bold">=</span> _mm256_set1_pd(params.constantX);
</span></span><span style="display:flex;"><span>          __m256d constY <span style="color:#000;font-weight:bold">=</span> _mm256_set1_pd(params.constantY);
</span></span><span style="display:flex;"><span>          __m256d escRadSq <span style="color:#000;font-weight:bold">=</span> _mm256_set1_pd(params.escapeRadiusSquared);
</span></span><span style="display:flex;"><span>          __m256i iterations <span style="color:#000;font-weight:bold">=</span> computeJulia(posX, posY, constX, constY,
</span></span><span style="display:flex;"><span>                                            escRadSq, params.maxIterations);
</span></span><span style="display:flex;"><span>          <span style="color:#458;font-weight:bold">int64_t</span> iterCounts[<span style="color:#099">4</span>];
</span></span><span style="display:flex;"><span>          _mm256_storeu_si256((__m256i <span style="color:#000;font-weight:bold">*</span>)iterCounts, iterations);
</span></span><span style="display:flex;"><span>          <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">4</span>; <span style="color:#000;font-weight:bold">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> (x <span style="color:#000;font-weight:bold">+</span> i <span style="color:#000;font-weight:bold">&lt;</span> surfaceWidth) {
</span></span><span style="display:flex;"><span>              <span style="color:#458;font-weight:bold">int</span> idx <span style="color:#000;font-weight:bold">=</span> std<span style="color:#000;font-weight:bold">::</span>min(iterCounts[i],
</span></span><span style="display:flex;"><span>                                 <span style="color:#000;font-weight:bold">static_cast</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int64_t</span><span style="color:#000;font-weight:bold">&gt;</span>(params.maxIterations));
</span></span><span style="display:flex;"><span>              ci<span style="color:#000;font-weight:bold">::</span>ColorA color <span style="color:#000;font-weight:bold">=</span> palette[idx];
</span></span><span style="display:flex;"><span>              accumulatedR[i] <span style="color:#000;font-weight:bold">+=</span> color.r;
</span></span><span style="display:flex;"><span>              accumulatedG[i] <span style="color:#000;font-weight:bold">+=</span> color.g;
</span></span><span style="display:flex;"><span>              accumulatedB[i] <span style="color:#000;font-weight:bold">+=</span> color.b;
</span></span><span style="display:flex;"><span>              accumulatedA[i] <span style="color:#000;font-weight:bold">+=</span> color.a;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">4</span>; <span style="color:#000;font-weight:bold">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> (x <span style="color:#000;font-weight:bold">+</span> i <span style="color:#000;font-weight:bold">&lt;</span> surfaceWidth) {
</span></span><span style="display:flex;"><span>          ci<span style="color:#000;font-weight:bold">::</span>ColorA finalColor(
</span></span><span style="display:flex;"><span>              accumulatedR[i] <span style="color:#000;font-weight:bold">/</span> totalSamples, accumulatedG[i] <span style="color:#000;font-weight:bold">/</span> totalSamples,
</span></span><span style="display:flex;"><span>              accumulatedB[i] <span style="color:#000;font-weight:bold">/</span> totalSamples, accumulatedA[i] <span style="color:#000;font-weight:bold">/</span> totalSamples);
</span></span><span style="display:flex;"><span>          surface.setPixel(ci<span style="color:#000;font-weight:bold">::</span>ivec2(x <span style="color:#000;font-weight:bold">+</span> i, y), finalColor);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="user-interactivity">User interactivity</h3>
<p>Users can interact by holding and dragging the mouse to move the fractal around. Use the mouse wheel to zoom in or out, the arrow keys to pan, and the <code>+</code>/<code>-</code> keys to adjust the zoom level.</p>
<p>This is achieved using Cinder&rsquo;s functionality provided by <code>mouseDown</code>, <code>mouseDrag</code>, <code>mouseUp</code>, <code>mouseWheel</code>, and <code>keyDown</code> events.</p>
<h3 id="results">Results</h3>
<p>Below are some renders with different constants:</p>
<p><img src="/assets/rendering-julia-set-fractal/render-1.png" alt="">
<img src="/assets/rendering-julia-set-fractal/render-2.png" alt="">
<img src="/assets/rendering-julia-set-fractal/render-3.png" alt="">
<img src="/assets/rendering-julia-set-fractal/render-4.png" alt=""></p>
<h2 id="smooth-zooming-with-asynchronous-rendering">Smooth zooming with asynchronous rendering</h2>
<p>We want to enable users to initiate a zooming animation that allows them to explore the mesmerizing details of the fractal. While we could simply render each frame with a new scale, doing so in real time would be too slow and cause stuttering. Instead, we will define an asynchronous renderer that handles the next zoomed frame in the background, while the app simulates the zoom by cropping and resizing the current image. Once the next frame is ready, it seamlessly swaps in, ensuring a smooth and responsive animation without putting excessive strain on performance.</p>
<p><img src="/assets/rendering-julia-set-fractal/async-renderer.png" alt=""></p>
<h3 id="renderer-class">Renderer class</h3>
<p>The <code>Renderer</code> class manages rendering tasks in a multi-threaded environment. It uses a background thread (<code>renderThread</code>) to process rendering requests. Requests include a surface to render to, render parameters, a color palette, and an optional callback function. These requests are queued and processed asynchronously.</p>
<ul>
<li><strong>requestRender</strong>: Adds rendering requests to the queue.</li>
<li><strong>run</strong>: The background thread processes requests by rendering them and calling the callback when done.</li>
<li><strong>Synchronization</strong>: A mutex ensures thread safety, and a condition variable manages thread synchronization.</li>
<li><strong>Graceful Shutdown</strong>: The render thread is stopped when the <code>Renderer</code> is destroyed.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">RenderRequest</span> {
</span></span><span style="display:flex;"><span>  ci<span style="color:#000;font-weight:bold">::</span>Surface32f <span style="color:#000;font-weight:bold">&amp;</span>surface;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> RenderParameters <span style="color:#000;font-weight:bold">&amp;</span>params;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> std<span style="color:#000;font-weight:bold">::</span>vector<span style="color:#000;font-weight:bold">&lt;</span>ci<span style="color:#000;font-weight:bold">::</span>Color<span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#000;font-weight:bold">&amp;</span>palette;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> std<span style="color:#000;font-weight:bold">::</span>function<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">void</span>()<span style="color:#000;font-weight:bold">&gt;</span> callback;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  RenderRequest(ci<span style="color:#000;font-weight:bold">::</span>Surface32f <span style="color:#000;font-weight:bold">&amp;</span>surf, <span style="color:#000;font-weight:bold">const</span> RenderParameters <span style="color:#000;font-weight:bold">&amp;</span>p,
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">const</span> std<span style="color:#000;font-weight:bold">::</span>vector<span style="color:#000;font-weight:bold">&lt;</span>ci<span style="color:#000;font-weight:bold">::</span>Color<span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#000;font-weight:bold">&amp;</span>pal,
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">const</span> std<span style="color:#000;font-weight:bold">::</span>function<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">void</span>()<span style="color:#000;font-weight:bold">&gt;</span> cb)
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">:</span> surface(surf), params(p), palette(pal), callback(cb) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Renderer</span> {
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>  Renderer() <span style="color:#000;font-weight:bold">:</span> running(<span style="color:#0086b3">true</span>) {
</span></span><span style="display:flex;"><span>    renderThread <span style="color:#000;font-weight:bold">=</span> std<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">thread</span>(<span style="color:#000;font-weight:bold">&amp;</span>Renderer<span style="color:#000;font-weight:bold">::</span>run, <span style="color:#000;font-weight:bold">this</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">~</span>Renderer() {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      std<span style="color:#000;font-weight:bold">::</span>lock_guard<span style="color:#000;font-weight:bold">&lt;</span>std<span style="color:#000;font-weight:bold">::</span>mutex<span style="color:#000;font-weight:bold">&gt;</span> lock(mtx);
</span></span><span style="display:flex;"><span>      running <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cv.notify_one();
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (renderThread.joinable()) {
</span></span><span style="display:flex;"><span>      renderThread.join();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">requestRender</span>(ci<span style="color:#000;font-weight:bold">::</span>Surface32f <span style="color:#000;font-weight:bold">&amp;</span>surface, <span style="color:#000;font-weight:bold">const</span> RenderParameters <span style="color:#000;font-weight:bold">&amp;</span>params,
</span></span><span style="display:flex;"><span>                     <span style="color:#000;font-weight:bold">const</span> std<span style="color:#000;font-weight:bold">::</span>vector<span style="color:#000;font-weight:bold">&lt;</span>ci<span style="color:#000;font-weight:bold">::</span>Color<span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#000;font-weight:bold">&amp;</span>palette,
</span></span><span style="display:flex;"><span>                     <span style="color:#000;font-weight:bold">const</span> std<span style="color:#000;font-weight:bold">::</span>function<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">void</span>()<span style="color:#000;font-weight:bold">&gt;</span> callback) {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      std<span style="color:#000;font-weight:bold">::</span>lock_guard<span style="color:#000;font-weight:bold">&lt;</span>std<span style="color:#000;font-weight:bold">::</span>mutex<span style="color:#000;font-weight:bold">&gt;</span> lock(mtx);
</span></span><span style="display:flex;"><span>      requests.emplace(surface, params, palette, callback);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cv.notify_one();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">private</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">thread</span> renderThread;
</span></span><span style="display:flex;"><span>  std<span style="color:#000;font-weight:bold">::</span>atomic<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">bool</span><span style="color:#000;font-weight:bold">&gt;</span> running;
</span></span><span style="display:flex;"><span>  std<span style="color:#000;font-weight:bold">::</span>queue<span style="color:#000;font-weight:bold">&lt;</span>RenderRequest<span style="color:#000;font-weight:bold">&gt;</span> requests;
</span></span><span style="display:flex;"><span>  std<span style="color:#000;font-weight:bold">::</span>mutex mtx;
</span></span><span style="display:flex;"><span>  std<span style="color:#000;font-weight:bold">::</span>condition_variable cv;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">run</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> (<span style="color:#0086b3">true</span>) {
</span></span><span style="display:flex;"><span>      std<span style="color:#000;font-weight:bold">::</span>unique_lock<span style="color:#000;font-weight:bold">&lt;</span>std<span style="color:#000;font-weight:bold">::</span>mutex<span style="color:#000;font-weight:bold">&gt;</span> lock(mtx);
</span></span><span style="display:flex;"><span>      cv.wait(lock, [<span style="color:#000;font-weight:bold">this</span>] { <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">!</span>requests.empty() <span style="color:#000;font-weight:bold">||</span> <span style="color:#000;font-weight:bold">!</span>running; });
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>running <span style="color:#000;font-weight:bold">&amp;&amp;</span> requests.empty()) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>requests.empty()) {
</span></span><span style="display:flex;"><span>        RenderRequest request <span style="color:#000;font-weight:bold">=</span> std<span style="color:#000;font-weight:bold">::</span>move(requests.front());
</span></span><span style="display:flex;"><span>        requests.pop();
</span></span><span style="display:flex;"><span>        lock.unlock();
</span></span><span style="display:flex;"><span>        renderJulia(request.surface, request.params, request.palette);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> (request.callback) {
</span></span><span style="display:flex;"><span>          request.callback();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="results-1">Results</h3>
<p>The following zooming was made with constant $-0.7269 + 1889i$</p>
<video 
  controls width="800"
>
  <source src="/assets/rendering-julia-set-fractal/zoom.webm" type="video/webm">
  Your browser does not support the video tag.
</video>

</main>

  <footer>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>
  
  <hr/>
  © 2025 Saad Mdaa
  
  </footer>
  </body>
</html>

